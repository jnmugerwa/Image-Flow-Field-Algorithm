import numpy as np
from scipy import signal
import cv2
import matplotlib.pyplot as plt

def get_orientation_image(image_path, smooth_sigma=3, sum_sigma=3):
    """
    Returns the orientation image of an image.
    
    Calculates the flow direction (angle of maximal variation) at each
    pixel. These angles can be used to create vectors within a mesh grid,
    creating a visual of the flow direction field of the image.
    
    Resources:
        "ANALYZING ORIENTED PATTERNS" (Kass, Witkin) 
        "Directional Field Computation for Fingerprints Based on the Principal
            Component Analysis of Local Gradients" (Bazen, Gerez)
        "Scribe Notes: Multivariate Gaussians and PCA" (Partridge)
        An ungodly amount of:
            StackOverflow
            numpy, scipy, etc. documentation
            Wikipedia
            Random slidedecks and pdfs from computer vision courses
        
    Parameters
    ----------
    image_path : string
        The filepath to an image.
    smooth_sigma : int, optional
        Standard deviation of the initial Gaussian filter.
        The default is 3.
    smooth_sigma : int, optional
        Standard deviation of the Gaussian kernel used in the weighed summation.
        The default is 3.
        
    Returns
    -------
    orientim : array
        An image/array, identically-sized to the input image/array. At each
        pixel is the flow-direction of the image at that pixel.
        
    See Also
    --------
    getOrientation() in OpenCV's PCA tutorial:
        https://docs.opencv.org/3.4/d1/dee/tutorial_introduction_to_pca.html 
        
    Example
    --------
    >>> image_path = r"C:\Users\natha\MULTI-SCALE MECHANICS\Test Images\Dendrites.jpg"
    >>> im = cv2.imread(image_path)
    >>> orientim = get_orientation_image(image_path)
    >>> plot_flow_field(orient_im, im)

    """
    # Make sure to cast entries as float, else truncation errors will arise.
    im = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE).astype('float')
    
    # Smooths image using a Gaussian kernel.
    smooth_im = cv2.GaussianBlur(im, (0, 0), smooth_sigma)
    
    gradients = np.gradient(smooth_im)

    Gx, Gy = np.asarray(gradients)
    
    # See Kass Paper. The smoothed versions of these will be used to 
    # ...calculate flow angles (parllel to Principal Axis 2) at each pixel.
    J1 = 2 * Gx * Gy
    J2 = np.square(Gx) - np.square(Gy)
    
    # Get Gaussian Kernel.
    size = np.floor(6 * sum_sigma)
    gauss_kernel = get_gaussian_kernel(size, sum_sigma)
    
    # Weighed summation using Gaussian kernel.
    J1star = signal.fftconvolve(J1, np.rot90(gauss_kernel, 2), mode='same') 
    J2star = signal.fftconvolve(J2, np.rot90(gauss_kernel, 2), mode='same')
    
    # Solving for the flow direction at each pixel.
    orientim = np.arctan2(J1star, J2star) / 2
    
    return orientim
    
def get_gaussian_kernel(size, sigma=3):
    """
    2D Gaussian kernel - should give the similar results as MATLAB's
    fspecial('gaussian',[shape],[sigma]). 
    
    All credit to: "ali_m" on StackOverflow :)
    
    Parameters
    ----------
    size : int
        Size of kernel.
    sigma : int, optional
        Standard deviation of Gaussian.
        The default is 3.
        
    Returns
    -------
    out : array
        An N-dimensional array containing a subset of the discrete linear
        convolution of `in1` with `in2`.
        
    See Also
    --------
    cv2.getGaussianKernel() : OpenCV's implementation, returning a 1-D kernel. 
        
    Example
    --------
    >>> get_gaussian_kernel(5, 1)
    >>> array([[ 0.002969,  0.013306,  0.021938,  0.013306,  0.002969],
    >>> [ 0.013306,  0.059634,  0.09832 ,  0.059634,  0.013306],
    >>> [ 0.021938,  0.09832 ,  0.162103,  0.09832 ,  0.021938],
    >>> [ 0.013306,  0.059634,  0.09832 ,  0.059634,  0.013306],
    >>> [ 0.002969,  0.013306,  0.021938,  0.013306,  0.002969]])

    """
    m, n = [(ss-1.)/2. for ss in (size, size)]
    y, x = np.ogrid[-m:m+1,-n:n+1]
    h = np.exp( -(x*x + y*y) / (2.*sigma*sigma) )
    h[ h < np.finfo(h.dtype).eps*h.max() ] = 0
    sumh = h.sum()
    if sumh != 0:
        h /= sumh
    return h

# 
def plot_flow_field(orient_image, original_image, sampling_interval=25):
    """
    Plots the flow field.
    
    Parameters
    ----------
    orient_image : array
        Array with flow directions (in radians) at each pixel.
    original_image : array
        The image from which orient_image was derived.
    sampling_interval : int, optional
        We will take a sample(direction from orient_image) 
        every "sampling_interval" steps.
        The default is 25.
        
    Returns
    -------
    Nothing; void.
        
    See Also
    --------
    Elided.
        
    Example
    --------
    See example in "get_orientation_image()"'s doc.
    
    """
    assert isinstance(sampling_interval, int), "Please give an integer sampling size."
    
    if sampling_interval < 20:
        print("You requested a very granular flow field; this may take" +
              " more time than usual")
    
    num_rows, num_cols = orient_image.shape
    
    # Subsample the orientation data according to the specified spacing.
    orient_im_samples = orient_image[::sampling_interval, ::sampling_interval]
    
    x, y = np.meshgrid(range(0, num_cols, sampling_interval), range(0, num_rows, sampling_interval))

    u = np.cos(orient_im_samples)
    v = np.sin(orient_im_samples)
    
    fig, ax = plt.subplots()
    
    # OpenCV reads images as BGR instead of RGB. Gotta re-convert to RGB.
    ax.imshow(cv2.cvtColor(original_image, cv2.COLOR_BGR2RGB))
    
    ax.quiver(x, y, u, v, color='r')
    
    fig.savefig('flow_field_image.png')